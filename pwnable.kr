 fd
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char buf[32];
int main(int argc, char* argv[], char* envp[]){
if(argc<2){
printf("pass argv[1] a number\n");
return 0;
}
int fd = atoi( argv[1] ) - 0x1234;
int len = 0;
len = read(fd, buf, 32);
if(!strcmp("LETMEWIN\n", buf)){
printf("good job :)\n");
system("/bin/cat flag");
exit(0);
}
printf("learn about Linux file IO\n");
return 0;
}

To be honest ,this code is so hard for me ,especially I only know a litte thing of c.
the main function has its parameters(参数)，such as int main(int argc, char* argv[])

       the number of parameters,at least one

      in fact ,argv[1] is data
  e.g.    if threr is a file named 1.sh   declare int main(int argc , char* argv[] ) when call it,use following command line： root@kali-linux:~# ./1.sh hahaha xixixi hehehe，we can know  argc=4，argv[0] is'1.sh' ，argv[1] is'hahaha'，argv[2] is 'xixixi'，argv[3] is 'hehehe'
if(argc<2)
                printf("pass argv[1] a number\n");
                return 0;
                //we need parameters at least two when we run fd
                
   // argc 为外部命令参数的个数，因此

      //  输入命令./edit时，argc==1;
       // 输入命令./edit file.txt时，argc==2；

   // argv[]为存储的命令，其中argv[0]即为可执行文件名；

        //输入命令./edit时,argv[0]=="./edit";
      //  输入命令./edit file.txt时，argv[0]=="./edit",argv[1]=="file.txt";
//例如：read(0,buf,20) 表示输入20个字节到buf缓冲区里，也就是read函数调用以后会在屏幕中等待我们的输入，并存储在缓冲区里（标准输入）

//write(1,buf,20)表示输出20字节到buf，并显示在屏幕中（标准输出）

   int fd = atoi( argv[1] ) - 0x1234;
    int len = 0;
    len = read(fd, buf, 32);
    if(!strcmp("LETMEWIN\n", buf)){
        printf("good job :)\n");
        system("/bin/cat flag");
        exit(0);
      //atoi : use it we can realise transform char into int  ,one more to pay attention,fd (file dsecriptor),if it equals to zero(0),we can stdio.
      fd@prowl:~$ ./fd 4660             
LETMEWIN 

//lLinux 中的man read 指令

READ(2)                    Linux Programmer's Manual                   READ(2)

NAME
       read - read from a file descriptor

SYNOPSIS
       #include <unistd.h>

       ssize_t read(int fd, void *buf, size_t count);

DESCRIPTION
       read()  attempts to read up to count bytes from file descriptor fd into
       the buffer starting at buf.

       On files that support seeking, the read operation commences at the cur‐
       rent  file  offset, and the file offset is incremented by the number of
       bytes read.  If the current file offset is at or past the end of  file,
       no bytes are read, and read() returns zero.

       If count is zero, read() may detect the errors described below.  In the
       absence of any errors, or if read() does not check for errors, a read()
       with a count of 0 returns zero and has no other effects.

